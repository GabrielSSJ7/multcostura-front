{"ast":null,"code":"\"use strict\";\n\nvar _axios = _interopRequireDefault(require(\"axios\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  changeFileName(file, newName) {\n    if (file) {\n      var blob = file.slice(0, file.size, \"image/png\");\n      const typeFile = file.type.split(\"/\");\n      const newFile = new File([blob], `${newName}.${typeFile[1]}`, {\n        type: file.type\n      });\n      return newFile;\n    }\n  },\n\n  deleteImage(id, type, image, {\n    f,\n    files,\n    keys\n  }, cleanUpFile) {\n    _axios.default.delete(`/images?id=${id}&type=${type}&image=${image}`).then(response => {\n      cleanUpFile(f, files, keys);\n      location.reload();\n    }).catch(err => {});\n  },\n\n  renderInputOrImages(images, objLength, _exclude) {\n    const _images = [];\n    const exclude = _exclude || [];\n\n    for (let x = 0; x < objLength; x++) {\n      let isNull = true;\n      images.forEach((img, i) => {\n        let snBar = img.split(\"/\");\n        let sn = snBar[snBar.length - 1];\n\n        if (!exclude.includes(x)) {\n          if (x == sn[0]) {\n            isNull = false;\n\n            _images.push(img);\n          }\n        } else {\n          isNull = false;\n        }\n      });\n      if (isNull) _images.push(null);\n    }\n\n    return _images;\n  },\n\n  validateImage(types, size, file) {\n    if (!file) return true;\n    let ok = false,\n        filesize = size / 1000;\n    const fileType = file.type.split(\"/\");\n    types.forEach(types => {\n      if (types == fileType[1]) ok = true;\n    });\n    if (filesize > 100) ok = false;\n    if (ok) return true;else return false;\n  },\n\n  getNameImageFromUrl(url) {\n    const splitted = url.split(\"/\");\n    const image = splitted[splitted.length - 1];\n    const imageSplitted = image.split(\".\");\n    return imageSplitted[0];\n  }\n\n};","map":{"version":3,"sources":["C:/Users/Gluz/Projects/web/multcostura/multcostura-web/src/utils/images.js"],"names":["module","exports","changeFileName","file","newName","blob","slice","size","typeFile","type","split","newFile","File","deleteImage","id","image","f","files","keys","cleanUpFile","axios","delete","then","response","location","reload","catch","err","renderInputOrImages","images","objLength","_exclude","_images","exclude","x","isNull","forEach","img","i","snBar","sn","length","includes","push","validateImage","types","ok","filesize","fileType","getNameImageFromUrl","url","splitted","imageSplitted"],"mappings":";;AAAA;;;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,cAAc,CAACC,IAAD,EAAOC,OAAP,EAAgB;AAC5B,QAAID,IAAJ,EAAU;AACR,UAAIE,IAAI,GAAGF,IAAI,CAACG,KAAL,CAAW,CAAX,EAAcH,IAAI,CAACI,IAAnB,EAAyB,WAAzB,CAAX;AACA,YAAMC,QAAQ,GAAGL,IAAI,CAACM,IAAL,CAAUC,KAAV,CAAgB,GAAhB,CAAjB;AACA,YAAMC,OAAO,GAAG,IAAIC,IAAJ,CAAS,CAACP,IAAD,CAAT,EAAkB,GAAED,OAAQ,IAAGI,QAAQ,CAAC,CAAD,CAAI,EAA3C,EAA8C;AAC5DC,QAAAA,IAAI,EAAEN,IAAI,CAACM;AADiD,OAA9C,CAAhB;AAGA,aAAOE,OAAP;AACD;AAEF,GAXc;;AAYfE,EAAAA,WAAW,CAACC,EAAD,EAAKL,IAAL,EAAWM,KAAX,EAAkB;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,KAAL;AAAYC,IAAAA;AAAZ,GAAlB,EAAsCC,WAAtC,EAAmD;AAC5DC,mBACGC,MADH,CACW,cAAaP,EAAG,SAAQL,IAAK,UAASM,KAAM,EADvD,EAEGO,IAFH,CAEQC,QAAQ,IAAI;AAChBJ,MAAAA,WAAW,CAACH,CAAD,EAAIC,KAAJ,EAAWC,IAAX,CAAX;AACAM,MAAAA,QAAQ,CAACC,MAAT;AACD,KALH,EAMGC,KANH,CAMSC,GAAG,IAAI,CAAE,CANlB;AAOD,GApBc;;AAqBfC,EAAAA,mBAAmB,CAACC,MAAD,EAASC,SAAT,EAAoBC,QAApB,EAA8B;AAC/C,UAAMC,OAAO,GAAG,EAAhB;AACA,UAAMC,OAAO,GAAGF,QAAQ,IAAI,EAA5B;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAApB,EAA+BI,CAAC,EAAhC,EAAoC;AAClC,UAAIC,MAAM,GAAG,IAAb;AACAN,MAAAA,MAAM,CAACO,OAAP,CAAe,CAACC,GAAD,EAAMC,CAAN,KAAY;AACzB,YAAIC,KAAK,GAAGF,GAAG,CAAC3B,KAAJ,CAAU,GAAV,CAAZ;AACA,YAAI8B,EAAE,GAAGD,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAAd;;AACA,YAAI,CAACR,OAAO,CAACS,QAAR,CAAiBR,CAAjB,CAAL,EAA0B;AACxB,cAAIA,CAAC,IAAIM,EAAE,CAAC,CAAD,CAAX,EAAgB;AACdL,YAAAA,MAAM,GAAG,KAAT;;AACAH,YAAAA,OAAO,CAACW,IAAR,CAAaN,GAAb;AACD;AACF,SALD,MAKO;AACLF,UAAAA,MAAM,GAAG,KAAT;AACD;AACF,OAXD;AAYA,UAAIA,MAAJ,EAAYH,OAAO,CAACW,IAAR,CAAa,IAAb;AACb;;AACD,WAAOX,OAAP;AACD,GAzCc;;AA0CfY,EAAAA,aAAa,CAACC,KAAD,EAAQtC,IAAR,EAAcJ,IAAd,EAAoB;AAC/B,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AACX,QAAI2C,EAAE,GAAG,KAAT;AAAA,QACEC,QAAQ,GAAGxC,IAAI,GAAG,IADpB;AAEA,UAAMyC,QAAQ,GAAG7C,IAAI,CAACM,IAAL,CAAUC,KAAV,CAAgB,GAAhB,CAAjB;AAEAmC,IAAAA,KAAK,CAACT,OAAN,CAAcS,KAAK,IAAI;AACrB,UAAIA,KAAK,IAAIG,QAAQ,CAAC,CAAD,CAArB,EAA0BF,EAAE,GAAG,IAAL;AAC3B,KAFD;AAGA,QAAIC,QAAQ,GAAG,GAAf,EAAoBD,EAAE,GAAG,KAAL;AACpB,QAAIA,EAAJ,EAAQ,OAAO,IAAP,CAAR,KACK,OAAO,KAAP;AACN,GAtDc;;AAuDfG,EAAAA,mBAAmB,CAACC,GAAD,EAAM;AACvB,UAAMC,QAAQ,GAAGD,GAAG,CAACxC,KAAJ,CAAU,GAAV,CAAjB;AACA,UAAMK,KAAK,GAAGoC,QAAQ,CAACA,QAAQ,CAACV,MAAT,GAAkB,CAAnB,CAAtB;AACA,UAAMW,aAAa,GAAGrC,KAAK,CAACL,KAAN,CAAY,GAAZ,CAAtB;AACA,WAAO0C,aAAa,CAAC,CAAD,CAApB;AACD;;AA5Dc,CAAjB","sourcesContent":["import axios from \"axios\";\n\nmodule.exports = {\n  changeFileName(file, newName) {\n    if (file) {\n      var blob = file.slice(0, file.size, \"image/png\");\n      const typeFile = file.type.split(\"/\");\n      const newFile = new File([blob], `${newName}.${typeFile[1]}`, {\n        type: file.type\n      });\n      return newFile;\n    }\n\n  },\n  deleteImage(id, type, image, { f, files, keys }, cleanUpFile) {\n    axios\n      .delete(`/images?id=${id}&type=${type}&image=${image}`)\n      .then(response => {\n        cleanUpFile(f, files, keys);\n        location.reload();\n      })\n      .catch(err => {});\n  },\n  renderInputOrImages(images, objLength, _exclude) {\n    const _images = [];\n    const exclude = _exclude || [];\n    for (let x = 0; x < objLength; x++) {\n      let isNull = true;\n      images.forEach((img, i) => {\n        let snBar = img.split(\"/\");\n        let sn = snBar[snBar.length - 1];\n        if (!exclude.includes(x)) {\n          if (x == sn[0]) {\n            isNull = false;\n            _images.push(img);\n          }\n        } else {\n          isNull = false;\n        }\n      });\n      if (isNull) _images.push(null);\n    }\n    return _images;\n  },\n  validateImage(types, size, file) {\n    if (!file) return true;\n    let ok = false,\n      filesize = size / 1000;\n    const fileType = file.type.split(\"/\");\n\n    types.forEach(types => {\n      if (types == fileType[1]) ok = true;\n    });\n    if (filesize > 100) ok = false;\n    if (ok) return true;\n    else return false;\n  },\n  getNameImageFromUrl(url) {\n    const splitted = url.split(\"/\");\n    const image = splitted[splitted.length - 1];\n    const imageSplitted = image.split(\".\");\n    return imageSplitted[0];\n  }\n};\n"]},"metadata":{},"sourceType":"script"}